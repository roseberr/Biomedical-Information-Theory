# -*- coding: utf-8 -*-
"""knn.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BgFxOFhqicvrR0cj1Rl77bBuf7QKhPhM
"""

import numpy as np
import os

ribo_data=np.loadtxt("/content/ribo-data.txt", delimiter="\t",dtype=str) #데이터를 받아올 경로 설정 
ribo_data=ribo_data[:,:79]
ribo_data=np.array(ribo_data,dtype='f')#ribo_data변수에 data 저장 

nonribo_data=np.loadtxt("/content/nonribo-data.txt", delimiter="\t",dtype=str) #데이터를 받아올 경로 설정
nonribo_data=nonribo_data[:,:79]
nonribo_data=np.array(nonribo_data,dtype='f')#nonribo_data변수에 data 저장

print("ribo_data.shape: ",ribo_data.shape)
print("nonribo_data.shape: ",nonribo_data.shape)

sum_data=np.concatenate((ribo_data,nonribo_data),axis=0)
print("ribo_data와 nonribo_data의 data를 sum_data로 합치기 진행.. ")
print("sum_data.shape: ",sum_data.shape)

# sum_target에 index값이 0이면 ribo data 1이면 nonribo data 
print()
sum_target=np.zeros((2467,1))
print("sum_data의 79 index에 target 값 넣기...   ")
print("sum_target에 index값이 0이면 ribo data 1이면 nonribo data 이다 ")

for i in range(121,2467):
    sum_target[i][0]=1

print("sum_target.shape:",sum_target.shape)

sum_data=np.hstack([sum_data,sum_target])

print("target 행렬 더한후 sum_data.shape:",sum_data.shape)

"""
sum_target=np.zeros((2467,1))

for i in range(0,2467):
    sum_target[i][0]=i

sum_data=np.hstack([sum_data,sum_target])

print("sum_data.shape:",sum_data.shape)
"""

# knn 구현 

def distance(p1, p2):# 두 행렬사이의 거리 구하기 
    return np.sqrt(np.sum(np.power((p2-p1),2)))

print("첫번쨰 data와 두번쨰 data사이의 거리 구해보기..",distance(sum_data[0],sum_data[1]))

from collections import Counter

def find_nearest_neighbors(cv_p, points, k, p): # p:cv 값중 하나   points:train data들 k=k   
    
    distance_result = np.zeros(len(points))
    
    for i in  range(len(points)):# p와 의 거리 계산 해서 distance_result에 넣고 sort 
        distance_result[i] = distance(points[i],cv_p )
        
    sorted_index = np.argsort(distance_result)[0:k]  #거리가가장짧은 배열 index k개 return 
  
    result = np.zeros(k)
    for i in range(k): #주변의 길이가 가장짧은 data의 유전자가 ribo인지 nonribo인지 확인 
        result[i] =sum_data[sorted_index[i]][79]
    vote_counts = Counter(result)#result에 저장된 값들의 개수 정리 

    #정해진 data의 값주변 거리가 짧은 data k개를 비교하고 그 비율이 p보다 높으면 ribo_data라고 판단한다 p보다 낮으면 non ribo 라고 판단 
    if (vote_counts[0]/(vote_counts[0]+vote_counts[1]))>=p: #positive #ribosom이라 판단
        if cv_p[79]==0:
            return "TP"
        elif cv_p[79]==1:
            #print(cv_p[80])
            return "FP"

    else: #negative #non ribosom이라 판단
        if cv_p[79]==0:
            return "FN"
        elif cv_p[79]==1:
            return "TN"
    return "error"

def cross_val_score():
    k=int(input("K값을 입력하세요 : "))
    p=float(input("P값을 입력하세요 : "))

    
    np.random.shuffle(sum_data) # 주어진 data shuffle 
    cut=np.zeros(7) #cut에는 shuffle된 data를 6-fold 수행하기위해서 6개로 전체 데이터를 나눠주는 기준점이 된다.

    TP=0 
    FP=0 
    TN=0 
    FN=0 
    error=0
    cut[0]=0
    cut[6]=len(sum_data)
    for i in range (1,6):
        cut[i]=int(round(len(sum_data)/6)*i)

    for i in range (0,6):
        points=np.concatenate((sum_data[0:int(cut[i])],sum_data[int(cut[(i+1)]):len(sum_data)]),axis=0)#points는 training data가 된다 
        #print(points.shape)

        #print(points.shape)
        for j in range(int(cut[i]),int(cut[i+1])):
            str=find_nearest_neighbors(sum_data[j],points,k,p) #knn 실행 
            if(str=="TP"):
                TP+=1
                #print("TP++")
            elif(str=="FP"):
                FP+=1
                #print("FP++")
            elif(str=="TN"):
                TN+=1
                #print("TN++")
            elif(str=="FN"):
                #print("FN++")
                FN+=1
            #elif(str=="error"):
                #error+=1
                #print("error++")
    print()
    print()
    print("K= ",k," P= ",p)
    print("TP의 개수:",TP )
    print("FP의 개수:",FP )
    print("TN의 개수:",TN )
    print("FN의 개수:",FN )
    #print("error의 개수:",error)      
    print("sensitivity: ",TP / (TP + FN) )
    print("specificity: ", TN/(TN+FP) )
    print("Accuracy: ",(TP+TN)/(TP+TN+FP+FN))

print("knn 함수 실행...")
cross_val_score()

os.system("pause")